<!DOCTYPE html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>def euler(x); cos(x) + i*sin(x); end</title>
  <meta name="description" content="This is the def euler(x); cos(x) + i*sin(x); end blog" />
  <meta name="keywords" content="blog,def euler(x); cos(x) + i*sin(x); end" />
  <meta name="generator" content="Jekyll" />
  <link href="/stylesheets/main.css" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/pygments.css" rel="stylesheet" type="text/css" />
  <link href="/feed/atom.xml" rel="alternate" title="Articles for Home" type="application/atom+xml" />

</head>
<body>
      <div id="header"><h1><a href="/">def euler(x); cos(x) + i*sin(x); end</a></h1>
    <p class="description">euler(PI) # => -1</p>
  </div>


  <div id="wrap">
    <div id="content">
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2012/12/11/a-ruby-design-process">A Ruby Design Process</a></h2>
            <div class="meta">
        <p><span class="date">11 December 2012</span></p>
      </div>

       <div class="entrybody"><p><strong>Ed:</strong> <em>Since the initial post, I have fixed some minor grammatical and
spelling errors pointed out by Rich Morin.</em></p>

<p>The Ruby programming language needs a design process.</p>

<p>I gave <a href="http://www.confreaks.com/videos/1278-rubyconf2012-toward-a-design-for-ruby">a talk on this
topic</a>
at RubyConf 2012. While the talk presented reasons why we need a design
process, I&rsquo;m mostly focusing on my proposal in this post. On Monday, December
10, 2012, we had an <a href="https://bugs.ruby-lang.org/projects/ruby/wiki/DevelopersMeeting20121210">IRC
meeting</a>
of Ruby implementers. Most of the components of my proposal were discussed.
However, I think a fair amount of misunderstanding remains. With this post, I
hope to offer some clarification.</p>

<h2 id="setting-a-stage">Setting a Stage</h2>

<p>Once upon a time, a very long time ago, there was a single implementation of
Ruby. Matz was the initial author and over time various people contributed to
the project. We generally refer to this implementation as <strong>MRI</strong> or <strong>Matz&rsquo;s
Ruby Implementation</strong>. Today, there are half dozen significant Ruby
implementations. These cover major platforms from the JVM to a Smalltalk VM to
Microsoft&rsquo;s DLR. Each of these platforms are quite different, having specific
limitations and advantages.</p>

<p>Matz still works on MRI to some extent, which is now only one implementation
out of many. Yet, for many people, MRI is still synonymous with Ruby. In other
words, people generally assume that &ldquo;the Ruby programming language&rdquo; and
whatever behavior MRI, the implementation, exhibits are one and the same
thing. However, Ruby is an extremely complex language with many special cases,
a big core library, and an even bigger standard library. For all the other
implementations of Ruby to have consistent behavior, there must be a way to
define <em>what is Ruby</em>.</p>

<p>We need a precise standard, or specification, for Ruby.</p>

<p>But wait, didn&rsquo;t I just say that we needed a design process for Ruby? Yes, I
did. A design process is a means to create a precise standard for Ruby. But
there is another reason that we need a design process for Ruby.</p>

<p>The world is constantly changing. As an industry, we have been reading and
hearing about the need to deal with concurrency as CPUs get more cores and
computers get more CPUs since the late 1980&rsquo;s (that&rsquo;s before a lot of
programmers today were born). But it is now becoming an unavoidable reality.
Discussions about concurrency in Ruby usually focus on the MRI global
interpreter lock. Unfortunately, that specific limitation of MRI gets an
unfair share of the attention. Concurrency and potential parallelism are much
bigger topics and need attention. A memory model, thread semantics,
concurrency primitives other than threads, and concurrent data structures are
all topics that must be addressed.</p>

<p>We are also seeing a huge change in the way applications are built and
deployed.  Heterogeneous networks of services deployed in the cloud and
interacting in unforeseen ways is the future. The future is not evenly
distributed but it is already all around us. In this environment, security is
a vital consideration.  Further, an extension API for Ruby to integrate with
libraries and applications written in numerous other languages is essential.
Not everything can be turned into a service natively and writing a service
layer may mean integrating a library or application written in another
language.</p>

<h2 id="the-great-benefits">The Great Benefits</h2>

<p>It should be wildly uncontroversial that everyone in the Ruby community
benefits from a specification for Ruby. What may be under-appreciated is who
exactly we are referring to when we say <em>the Ruby community</em>. My definition is
broad and includes people who use applications written in Ruby, businesses who
use applications written in Ruby, businesses who pay people to write
applications in Ruby, and people who are paid to write applications in Ruby.</p>

<p>Ruby is a mature, industrial-strength programming language. Hundreds of
millions of dollars have been invested in Ruby, Ruby companies, and Ruby
applications. Think about that for a moment. About six years ago, a few
hundred Rubyists attended the first RailsConf. Many of them were not being
paid to write Ruby or Rails applications yet. That&rsquo;s just six years ago.
Today, it is hard to find a person attending a RubyConf or RailsConf or any of
numerous regional Ruby conferences who is not paid to write Ruby. That is a
huge number of families that depend on a salary that comes from writing Ruby
code.</p>

<p>It is incumbent upon all of us who can make a difference to ensure that we
give our best effort to make good decisions for Ruby. Decisions that further
the quality, reliability, security, and usability of Ruby. Decisions that
safeguard the well-being of people that depend on Ruby.</p>

<h2 id="a-decent-proposal">A Decent Proposal</h2>

<p>The foremost goals for this proposed Ruby design process are 1) the <em>quality</em>
of decisions made about Ruby, and 2) language unity.</p>

<p>I want this point to be as clear as possible. Ruby is a fantastic language.
It does not need huge changes. What Ruby needs is stability, unity, and
changes that address the challenges for using Ruby to create modern
applications. Wherever this proposed process seems heavy, it has been
<em>designed</em> to produce good decisions and limit Ruby changes.</p>

<p>Here is the proposed process:</p>

<ol>
  <li>A <em>Ruby Design Council</em> made up of representatives from any significant
Ruby implementation, where significant means able to run a base level of
RubySpec (which is to be determined).</li>
  <li>A proposal for a Ruby change can be submitted by any member of the Ruby
Design Council. If a member of the larger Ruby community wishes to submit a
proposal, they must work with a member of the Council.</li>
  <li>The proposal must meet the following criteria:
    <ol>
      <li>An explanation, written in English, of the change, what use cases or
problems motivates the change, how existing libraries, frameworks, or
applications may be affected.</li>
      <li>Complete documentation, written in English, describing all relevant
aspects of the change, including documentation for any specific methods
whose behavior changes or behavior of new methods that are added.</li>
      <li>RubySpecs that completely describe the behavior of the change.</li>
    </ol>
  </li>
  <li>When the Council is presented with a proposal that meets the above
criteria, any member can decide that the proposal fails to make a case that
justifies the effort to implement the feature. Such veto must explain in
depth why the proposed change is unsuitable for Ruby. The member submitting
the proposal can address the deficiencies and resubmit.</li>
  <li>If a proposal is accepted for consideration, all Council members must
implement the feature so that it passes the RubySpecs provided.</li>
  <li>Once all Council members have implemented the feature, the feature can be
discussed in concrete terms. Any implementation, platform, or performance
concerns can be addressed. Negative or positive impact on existing
libraries, frameworks or applications can be clearly and precisely
evaluated.</li>
  <li>Finally, a vote on the proposed change is taken. Each implementation gets
one vote. Only changes that receive approval from all Council members
become the definition of Ruby.</li>
</ol>

<h3 id="a-ruby-design-council">1. A Ruby Design Council</h3>

<p>A council of people with many different and sometimes competing interests has
been used at every level of government and organizations to ensure that
different viewpoints are considered and reasonably good decisions are made.</p>

<p>A council is the only equitable way to ensure that the definition of Ruby
fairly considers all the competing interests that exist. If the process is not
equitable, it will not be respected. The unity of the Ruby language is
something of tremendous value to the Ruby community.</p>

<h3 id="submitting-a-proposal">2. Submitting a Proposal</h3>

<p>I must emphasize that the proposal is not where the process of working on a
Ruby feature begins.</p>

<p>Any implementation is free to experiment with Ruby changes in any way they
choose and using whatever testing or coding style they select. They are free
to discuss the process in any forum using any language they choose.</p>

<p>Writing code and playing with it is one of the main ways to get a feel for a
feature. The design process proposed here does not intend to interfere with
that. It is also expected that discussions and collaboration between different
Council members would be undertaken long before a proposal is submitted.</p>

<p>Ruby is a very complex language. Changes to Ruby should not be considered
lightly. Ruby is not a playground. It is a language that has a responsibility
to a huge community.</p>

<p>Requiring that a proposed change be made by a Council member ensures that
poorly fitting changes are not added to Ruby. At the same time, any change
that has a clear and significant benefit deserves the effort to be presented
in a way that ensures it will be understood by the Council members and taken
seriously.</p>

<h3 id="criteria-for-a-proposal">3. Criteria for a Proposal</h3>

<p>Proposing a change to Ruby is not a trivial undertaking. It should be
deliberate and carefully thought out. It is not an unreasonable burden to
require that a proposed change be completely understood by the member
proposing it.</p>

<p>Writing documentation and RubySpecs is the best way to ensure that the
proposed change is understood and can be communicated to the rest of the
Council. Since the goal is the best decisions we can make for Ruby, setting a
high expectation for a proposal is a benefit.</p>

<h3 id="proceeding-with-a-proposal">4. Proceeding with a Proposal</h3>

<p>Any proposed change that has met these criteria has been carefully thought out
and described. The specific details of behavior have been written down in a
way that any implementation can implement.</p>

<p>However, that does not mean the proposal is a good idea for any number of
possible reasons. As an initial sanity check, all Council members must decide
whether the effort to implement the feature is justified. This barrier should
be viewed as an additional guarantee that changes to Ruby will be adequately
understood and carefully selected for the benefit of the Ruby community.</p>

<h3 id="implementing-a-proposal">5. Implementing a Proposal</h3>

<p>Every Council member must implement a proposal that passes the initial
evaluation. The RubySpecs provided in the proposal will guide and clarify the
implementation.</p>

<p>Confronting the platform and system constraints while implementing the feature
ensure that it is completely understood. Likewise, having a complete and
working implementation is the best way to limit unintended consequences and
understand as much as possible how existing code will be affected by the new
feature.</p>

<h3 id="discussing-the-implementation">6. Discussing the Implementation</h3>

<p>Once the proposal has been implemented by all Council members, the time is
ripe for discussion. It is only with the concrete reality of how the feature
performs and interacts with the rest of Ruby that good decisions can be made.</p>

<p>The express intent of all Council members is to implement a <em>unified</em>
definition of Ruby. If the feature is going to be Ruby, it is going to be
implemented by all members. It presents no burden to require that the
implementation precede the discussion. If, after implementation, the feature
fails to meet the needs that motivated it, everyone can be satisfied that the
best possible evaluation was given. If unforeseen implementation issues are
discovered, the feature can be revised and resubmitted.</p>

<h3 id="voting-on-a-proposal">7. Voting on a Proposal</h3>

<p>Just as a council is the equitable way to share responsibility and decisions
about Ruby, so it must be that every Council member&rsquo;s vote has equal validity.
It is true that every Council member holds veto power. But that should be seen
as a strength of the process, not as a liability.</p>

<p>Matz still has the ability to say what features become officially Ruby. He can
exercise his vote to not approve any feature. However, the rest of the Council
could also vote not to approve a feature that Matz wanted. If this causes the
slightest bit of fear for the well-being of Ruby, please allow me to dispel
it.</p>

<p>First of all, the Council is made up of people who have spent <em>years</em>
implementing Ruby. Many of those people spend some of their time as unpaid
volunteers. Every one of those people up to now has committed tremendous
effort to create a compatible implementation of Ruby <em>even when no actual
specification existed</em>.</p>

<p>Furthermore, people like Charles Nutter have gone to tremendous lengths to
implement features like POSIX-compatible behavior on top of the JVM so that
Ruby compatibility would be respected. That level of dedication must be
respected and applauded, not feared. We have all put the well-being of Ruby
first, and if we truly feel that a feature would cause harm to Ruby, we should
be allowed to prevent it from being included in the definition of Ruby.</p>

<p>In practice, I have absolutely no reservation about giving veto power to any
member of the Ruby Design Council.</p>

<h2 id="what-really-changes">What Really Changes?</h2>

<p>By formalizing a design process for Ruby, what really changes about how we do
our work?</p>

<p>Nothing in this proposal prevents any implementation, including MRI, from
experimenting with Ruby features. Any, or all, of the Council members could
collaborate on a proposed change to Ruby. An experiment for a new feature
could be used by a portion of the Ruby community for a significant period of
time before being formally included in Ruby. Any implementation is free to
discuss a feature in their own way and with their own preferred version
control system, bug tracker, testing methodology, means of communication and
language.</p>

<h2 id="technology-for-change">Technology for Change</h2>

<p>Finally, the question of what technology to use for submitting, discussing,
tracking, and voting on proposals must be addressed.</p>

<p>Email is not sufficient and neither is a bug tracker. We need an application
that allows commenting on each sub-section of a proposal, referencing multiple
previous comments in a comment, viewing comments by proposal or by
sub-section, tracking changes to a proposal, tracking references to RubySpecs
and implementation code, and recording votes. The contents of proposals should
be searchable and indexable. The process of deciding on proposals should be
secure and audit-able.</p>

<p>I will create a specific application for this purpose and host it at
<a href="http://design.rubyspec.org">design.rubyspec.org</a>. Ruby deserves a
sufficiently powerful tool to support making good decisions for the language.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Ruby needs a design process. The process described here focuses on language
unity and making good decisions for the Ruby community. The process gives
maximum liberty to all implementations of Ruby to experiment with new features
while giving maximum clarity and support for the Ruby Design Council members
to decide which proposed Ruby changes to accept.</p>

<p>We can choose to make the Ruby design process as efficient and effective as we
wish. The intention should be collaboration and unity. Ruby, and especially
the Ruby community, deserve our best effort.</p>
</div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2012/4/9/is_node_js_better">Is Node.js Better?</a></h2>
            <div class="meta">
        <p><span class="date">09 April 2012</span></p>
      </div>

       <div class="entrybody"><p><strong>NOTE:</strong> <em>This is essentially a transcript of (though mostly written before)
my JSConf 2012 talk, &ldquo;Is Node.js better?&rdquo;. It&rsquo;s long, I know. There is no
tl;dr, sorry.</em></p>

<p><strong>Is this better than that?</strong></p>

<p>This is a question that we confront constantly. Numerous times a day, in fact.
And sometimes a lot rides on the answer. Is this job offer better than that
one? Is this car better than that one? Is this home for my ailing mother
better than that one? Is this billing system better than that one? Is this tax
plan better than that one?</p>

<p>This question is everywhere. We cannot escape it. Yet for the frequency with
which we confront it, our approach to resolving the question is quite likely
<em>not</em> objective. Which is to say, we are probably not answering the question
in a way that is mostly likely to benefit us. Many used car sales, software
system sales, and political campaigns, to mention a few things, profit from
our incompetence answering this question. We&rsquo;ll consider some of the reasons
why that is true later. But just recognizing this is rather distressing.</p>

<p>But we&rsquo;re not just asking, &ldquo;is this better than that?&rdquo; in general; we&rsquo;re here
at JSConf and this talk is about Node.js. Why? You probably know that I&rsquo;m not
a notable member of the Javascript community. I have not authored a single JS
library. I&rsquo;ve never given a talk at a JSConf. Why am I here? And why am I
talking about Node.js?</p>

<p>I met Chris Williams at <a href="http://codeconf.com/">CodeConf 2011</a>, organized by
<a href="https://github.com/">Github</a>. Chris sat down next to me during the Node.js
talk by Ryan Dahl. I found the talk fascinating because much of it focused on
improving the non-blocking I/O facilities in V8 for both Windows and Unix-ish
platforms. This was something that we have a lot of interest in for the
Rubinius project and I had then recently started porting Rubinius to Windows.</p>

<p>At the time, I had no idea who Chris was. But we chatted a bit and at the
break, Chris stood up and said, &ldquo;I&rsquo;m going to get some more beer, would you
like some?&rdquo; Holy shit. <em>That&rsquo;s why I had been smelling beer for the last 45
minutes!</em> Chris had a coffee cup full of beer. Hilarious. One person&rsquo;s
moderation is another person&rsquo;s excess.</p>

<p>I declined the beer then but we exchanged contact info and Chris put me in
touch with folks from Microsoft who were assisting with getting Node.js
running well on Windows. Chris also informed me of the upcoming JSConf that
was being held in Portland, where I live. It was too late to get tickets but I
was able to attend the opening party and made a point to hang out as much as I
could with the other attendees at conference events. At the time of CodeConf,
I was merely curious about Node.js, but I didn&rsquo;t have much of an opinion.</p>

<p>Fast-forward almost nine months. I was seeing a flurry of tweets about
Node.js. This got my attention, in part because of the people who where
tweeting about it. I use Twitter as one of my main sources of information
about developing technology. The more tweets I saw, the more uneasy I felt.
Finally, one morning I posted this:</p>

<p><img src="/images/node_challenge.png" alt="Node.js challenge" /></p>

<p>My intent was not to be antagonistic. Rather, my challenge was focused on
finding out what sort of problems people were solving with Node.js. But any
challenge, even a sincere one, carries a connotation of aggressiveness. And it
is a fact of human nature that when pushed, people tend to push back. Some of
the responses to my tweet attempted to share knowledge but others were
understandably of the genre, &ldquo;if you&rsquo;re looking for a fight, you&rsquo;ll find one
here.&rdquo;</p>

<p>It wasn&rsquo;t long before Chris DM&rsquo;d me and basically said, &ldquo;What&rsquo;s up with this
&lsquo;challenge&rsquo;? You are working on important stuff, why are you wasting time on
this?&rdquo; I answered that I was genuinely interested in understanding why people
are using Node.js. We exchanged a few comments over a several days and Chris
asked if I was willing to do a talk on the subject. So that is how I got here,
talking about Node.js at JSConf. It is a honor and privilege to be here and I
thank Chris and the conference organizers, as well as all of you.</p>

<p>So who am I? I&rsquo;ve been working on the <a href="http://rubini.us">Rubinius</a> project for
the past five years, and four of those while employed full-time by <a href="http://engineyard.com">Engine
Yard</a>. I started the <a href="http://rubyspec.org">RubySpec</a>
project as part of my work on Rubinius. Through my work on Rubinius, I have
learned a lot about compilers, virtual machines, garbage collectors, and
importantly, concurrency. One of the notable points about Rubinius is we have
removed the global interpreter lock (GIL) so that multiple native threads can
run Ruby code in parallel on multi-core or multi-CPU hardware. We see this
ability as vital to the success of Rubinius.</p>

<p>Now that you know how I came to be speaking at JSConf and you know a little
about what I do, the question remains, &ldquo;<em>Why</em> am I speaking at JSConf? Why do
I care about Node.js?&rdquo; The answer to that will take us on a journey through
some interesting territory. I only ask that you suspend prejudice and follow
along. If you ultimately disagree with me, there is nothing wrong with that.</p>

<p><em>Organizations tend to perpetuate the problem they were created to solve.</em></p>

<p>I don&rsquo;t remember exactly when I was introduced to this idea, but it had a
significant effect on me. There are a lot of difficult problems to solve in
the world and one of the first things we tend to do is create an organization
that is dedicated to some aspect or another of a solution. Notice that there
is a difference between people organizing to solve a problem and an
organization. As soon as we have an organization, it will tend to take actions
to perpetuate itself. Of course, these actions are really the decisions of
people <em>in</em> the organization. The organization has no effective power
independent of the people who comprise it, yet the organization as a whole is
a system, and will tend to exhibit life-preserving actions. If an organization
exists to solve a problem, and that problem is solved, the organization ceases
to have a reason to exist.</p>

<p>Every time we organize for any reason, there is a tendency for structures to
solidify. The rigidity of those structures tend to inhibit movement and change
as circumstances change. Therefore, a vital force in social organization is
the force that opposes established order. There is a name for this force:
<em>subversive</em>, something seeking or intending to subvert an established system
or institution. People who participate in subversive activities are called
subversives.</p>

<p>There is another aspect to this that is important. People tend to be in one of
two groups: those who fear change and those who create change. When we think
of &ldquo;change&rdquo;, it usually has a positive connotation, and &ldquo;subversive&rdquo; has a
negative connotation. But they are often the same thing. Change can be
positive or negative. But as it has been said, &ldquo;there is only one constant:
change.&rdquo;</p>

<p>Javascript has been an amazing technology wielded by people who have radically
and fundamentally changed how we interact on the web. This is fascinating and
tremendously valuable for societies all over the world. So part of the reason
why I&rsquo;m speaking here is that people enthusiastic about Javascript are people
who are creating change. I want to acknowledge, assist, encourage, collaborate
with, and influence people who are actively working to change the world for
the better.</p>

<p>This talk is about conflict resolution. Conflict is inherent in the question,
&ldquo;Is this better than that?&rdquo;</p>

<p>It&rsquo;s important to note that any contrast implies conflict. Sometimes people
assert that you should be able to promote something without saying anything
bad about something else. This idea is impossible to comprehend. If I say,
&ldquo;water is good,&rdquo; it is inherent, even when implicit, that I&rsquo;m saying water has
value and value is a concept that relies on a context and a standard. There is
no concept of value that is not relational. Something is only good relative to
what you are judging it against.</p>

<p>Criticism is advocacy; advocacy is criticism. Criticism is also controversy
and controversy is entertaining. However, despite the entertainment value,
different ways of resolving conflict can have very negative consequences.
Usually when there is conflict, we address it with aggression. We talk about
having a &ldquo;shootout&rdquo;, &ldquo;fight&rdquo;, &ldquo;throw down&rdquo;, etc. But are fights a healthy,
beneficial way to resolve controversy?</p>

<p>Further, when a person comes out as a strong advocate for some technology,
people opposed to the technology will hurl the epithet &ldquo;fanboi&rdquo; as an attempt
to discredit the idea by attacking the person. From the other direction, if we
don&rsquo;t like someone&rsquo;s criticism, we may call the person a &ldquo;troll&rdquo;.</p>

<p>Other times, we will simply attempt to avoid conflict entirely. In Ruby, there
is this idea, MINASWAN: <em>Matz is nice and so we are nice.</em> There is nothing
wrong with being nice, but why is &ldquo;nice&rdquo; contrasted with &ldquo;criticism&rdquo;? Are we
supposed to never challenge someone because being &ldquo;nice&rdquo; is more important and
challenging them is inherently not nice?  What if someone is doing something
that from our experience is not beneficial to themselves or others?</p>

<p>For the most part, this is how I see us dealing with conflict. We either avoid
it or we attempt to devalue the person rather than discuss the idea. This is
dysfunctional. Basically, we suck at conflict.</p>

<p>How can we improve how we deal with conflict?</p>

<p>I assert that we need to use science. But how? What does that mean? To
understand this, we need to look more deeply at how we as humans think. But
before we get to that, let&rsquo;s consider a very common aspect of social
organization: the tendency to surrender our own judgment to that of an
&ldquo;expert&rdquo;.</p>

<p>In 1948, Alex Osborn, who was an ad man at B.B.D.O., wrote a book, <em>Your
Creative Power</em>, where he introduced &ldquo;brainstorming&rdquo;. Essentially, a group of
people toss out solutions to a problem under consideration. The emphasis is on
generating as many ideas as possible. A key element of the activity is that
everyone is told not to criticize their own or other&rsquo;s ideas. It was asserted
that creativity was too delicate a process to withstand the harsh light of a
critical challenge.</p>

<p>Of course, that made a lot of sense to people. Over the years, brainstorming
has been used extensively in problem solving. It is still heavily used. The
problem is, the method is flawed. The proscription against criticism happens
to be wrong.</p>

<p>There were two studies that tested the two main components of the
brainstorming methodology for discovering creative solutions. The first
focused on individuals versus groups. The result was that people working alone
produced not just more but better ideas than the groups.</p>

<p>The second study focused on the suspension of criticism. The subjects were
divided into three groups. The first group were instructed to use
brainstorming and told not to criticize their own or each other&rsquo;s ideas. The
second group were instructed to challenge and debate one another. The last
group was allowed to organize themselves without any instruction in a
particular method. The results from this experiment were unambiguous. The
debaters significantly outscored both other groups. The act of criticizing
other&rsquo;s ideas causes both the questioner to understand the idea more fully and
the person proposing the idea to go more deeply into it.</p>

<p>The important lesson is two-fold. Criticism is an important aspect of
creative, intellectual effort. Despite the proscription against criticism
having superficial validity, it was rather easily disproved.</p>

<p>Another interesting study related to creativity examined whether there was a
correlation between the success of Broadway musicals and how well the team
producing the musical knew each other. The measure of team familiarity was
named the Q factor. A team where all the members had worked together before
would have a high Q factor. A team where no members had worked together before
would have a low Q factor. The study found that there was indeed a significant
statistical correlation between Q factor and success of a musical. In other
words, a certain range of Q factor was a good predictor of success. The value
of Q that was most likely to predict success was from a team where most
members had worked together previously but some members had not. A team where
no one had worked together wasn&rsquo;t able to communicate effectively enough. A
team where everyone had worked together didn&rsquo;t benefit from an outsider&rsquo;s
perspective challenging ideas.</p>

<p>These results are reported in <em>Groupthink: The Brainstorming Myth</em> by Jonah
Lehrer, published in <em>New Yorker</em> magazine, January 30th, 2012. The lesson we
can take is that criticism is important to creative solutions to problems and
we should be seeking people who are unfamiliar with our favorite language or
framework to join us and help our understanding of problems and the solutions
we are building.</p>

<p>Another lesson is that there is nothing that prevents a well-meaning and
experienced expert from being wrong. One thing that we should all be
challenging is &ldquo;appeals to authority&rdquo; in decision making. As you can see from
the following tweet, Ward Cunningham thinks Node.js is the future of the
server side. However, that assertion is most likely not taken by readers of
the tweet as a neutral assertion of fact about Ward&rsquo;s opinion. It is taken as
meaningful because Ward said it. Further, it is unremarkable that the
assertion is unaccompanied by any evidence with which to help determine the
validity of the assertion. Assertions by experts with no accompanying evidence
are the <em>status quo</em> in our industry, and that should be extremely
embarrassing.</p>

<p><img src="/images/node_future.png" alt="Appeal to authority" /></p>

<p>The next part of our journey takes us to one of the most interesting books I
have read. <em>Thinking Fast and Slow</em> by Daniel Kahneman (Farrar, Straus and
Giroux, 2011) is a book about how our minds work. There are basically two
modes that have distinct and surprising features in the way we think. These
two modes influence one another.</p>

<p>One mode is called fast thinking because our brains activate an entire network
of associations in a sub-second burst of activity. For example, if I display
the word &ldquo;bacon&rdquo;, you will immediately have numerous memories and associations
with bacon coming into awareness. This fast mode is all about pattern matching
and the associations activated can be extensive and surprising. In this mode,
the brain over-achieves, if you will. It activates far more associations than
may be needed. And some associations may be surprising. It is up to the second
mode to use those associations depending on the task we are confronted with.</p>

<p>The other mode is called slow thinking and is related to such activities as
concentration, judgment, monitoring, and selecting. If I ask, &ldquo;what is 23 x
47?&rdquo; Answering this requires deliberate application of a set of tasks to
arrive at the answer, unless the problem is one we are quite familiar with,
in which case the fast thinking would just produce the answer as an
association.</p>

<p>The book is filled with fascinating knowledge about how our thinking works and
I cannot recommend it highly enough. It discusses numerous ways in which our
thinking can produce erroneous beliefs and ideas. One of the very interesting
results is that our deliberate, slow thinking can be easily fooled into
accepting a wrong answer provided by our fast thinking mode if we feel at
ease. But if we feel anxious, our slow thinking mode will be more critical and
less likely to just accept an answer provided by our fast thinking mode.</p>

<p>Reading <em>Thinking Fast and Slow</em> and reflecting on the complex and
inter-related behaviors that scientists have been able to discover facts about
led me to the following conclusion:</p>

<p><em>Programming is a behavioral science.</em></p>

<p>Behavioral science is a very broad category that encompasses disciplines that
explore the activities and interactions among organisms through systematic
analysis and investigation using controlled observation and scientific
experimentation.</p>

<p>There is a distinction between programming and computer science. Writing
software is an activity that is mostly centered on human behaviors. Most
software will interact with people at some point. Basically, it is written by
people, for people, and funded by people. Of course, there are mathematical
foundations of computing and algorithms, but those are rarely the most
important elements of the process of creating software.</p>

<p>If you are familiar with the many methodologies under the &ldquo;Agile&rdquo; umbrella,
you know that dealing with changing requirements is one of the most complex
aspects of software construction. But note that those changes are almost
entirely due to human behaviors. If we build a bridge, an environmental study
will determine most of the forces that the bridge design must account for.
Further, the laws of physics are quite well established. Engineering the
bridge is not a terribly complex activity. However, in software, there is not
a good way to clearly establish the constraints for the system we are
building. People are responsible for most of the complexity in programming.
That is why I assert it is a behavioral science.</p>

<p>What is curious to me is that a typical undergrad psychology student will
likely have more exposure to research methods than a typical computer science
undergrad or even graduate student. Research methods are activities directed
at determining the <em>validity</em> of assertions. They are what enable us to
separate knowledge from opinion. Fundamentally, they are related to two
aspects of existence: the nature of the world (meta-physics) and the theory of
knowledge (epistemology). To learn more about this, I would recommend
<em>Research Methods: the basics</em> by Nicholas Walliman (Routledge 2011).</p>

<p>Turning from this general information about applying science to thinking and
learning about research methods, let&rsquo;s look at Node.js again. One of the major
assertions about Node.js is that it permits writing efficient web servers that
must deal with many concurrent connections. So, let&rsquo;s look at some basic
features of concurrency, including a possible definition of concurrency.</p>

<p><em>People are selfish, lazy, and easily bored.</em></p>

<p>I say that without any moral judgment. I think these are all biologically
desirable features of organisms. We are selfish because we are responsible for
our own well-being. We are lazy so we don&rsquo;t waste precious and
costly-to-obtain energy. We are easily bored because we must constantly
incorporate new material to maintain our existence. Of course, each of these
attributes has an opposite and any individual will exhibit a combination of
these behaviors. But these three attributes are interesting to consider in
this context.</p>

<p>Scarcity is a fact of life. Infinity is a mathematical fantasy. There are a
finite number of computers.</p>

<p>Combine scarcity with the attributes above about people and we have a reason
for concurrency in computation.</p>

<p>When a single CPU with a single core is running, it can basically execute one
instruction at a time. Of course, this is a simplification, but it is
basically true. If we consider a program to be a sequence of instructions,
I<sub>1</sub>..I<sub>n</sub>, every possible ordering of those instructions is
a plausible definition of concurrency. For example, a four instruction program
could be I<sub>1</sub>, I<sub>2</sub>, I<sub>3</sub>, I<sub>4</sub> or
I<sub>3</sub>, I<sub>1</sub>, I<sub>2</sub>, I<sub>4</sub>, etc. Not all
orderings are going to be meaningful given the semantics we expect from the
program.</p>

<p>Now, consider that the program would be 100% efficient if all the instructions
are dedicated to solving the problem for which the program exists. However, if
any instructions are dedicated to changing the order of instructions, those
would reduce the efficiency of the program by doing work that is not directly
related to solving the problem.</p>

<p>Once upon a time, computers solved problems one at a time. The jobs were
processed from start to finish one at a time. This is great for efficiency but
not great for people. People don&rsquo;t want to wait for everyone else&rsquo;s job to
finish before theirs. Nor are they willing to do a lot of extra work to make
the computer most efficient. So the idea of time-sharing systems was born.
Essentially, everyone got a little slice of time to use the CPU. Even though
some efficiency was lost, and so everyone&rsquo;s program would ultimately take
longer to complete, the average time to wait went from hours (a whole day,
perhaps) to possibly a few minutes. Computers became interactive.</p>

<p>There are only a few mechanisms to re-order the instructions of a sequential
program. (Note that we can generalize from the instructions of a single
program to the instructions of a set of programs concatenated together. The
fundamental considerations do not change.) One way would be to do a little
work and then voluntarily yield control of the CPU to another program.  At
some later time, another program would yield control back to us. This would
implement cooperative multitasking. Another way would be for some sort of
supervisor to allocate a short amount of time to each program in sequence.
This would implement pre-emptive multitasking. Once your time-slice is over,
you simply have to wait until everyone else gets a time-slice before you can
run again. Yet another way would be to allow a program to run until it
performed some action, like writing to the display or reading from the disk.</p>

<p>Each of these mechanisms for interleaving the instructions of a serial program
may have different trade-offs, and consequently, different efficiencies.
However, there is nothing inherent in any method that dictates it would be
more efficient than any other. I consider this a very important point missing
from almost every assertion about the uniqueness of Node.js. People are
saying, and others are repeating, that Node.js enables solutions that are not
possible with other programming languages and frameworks. This is absolutely
false.</p>

<p>There is a lot more to understand about concurrency, modern CPUs, and
efficiency than we can cover here. However, if you are concerned with the
validity of the assertion that Node.js is good technology for writing
efficient web servers, then you may want to understand more about concurrency.</p>

<p>Besides concurrency, there are a number of justifications given for using
Node.js. Are these justifications valid? I think consistency is important. If
I say X is better than some Y because of some reason J, and there is some X&rsquo;
that is basically equivalent to X and Y&rsquo; equivalent to Y, then X&rsquo; should
probably be better than Y&rsquo; for the same reason J. That idea is expressed in
symbols below, where the long horizontal line means that the statements above
logically <em>imply</em> the statement below the line.</p>

<p><img src="/images/justification.png" alt="Justification" /></p>

<p>One reason given for using Node.js is that the same language, Javascript, can
be used on both the client and the server. If that is true, then why shouldn&rsquo;t
someone use <a href="https://developers.google.com/web-toolkit/">GWT</a> and use Java on
both the client and server? Since the JVM works very well on the server,
certainly the effort put into GWT could be seen as the equivalent of the
effort put into Node.js to make a browser technology work well on the server.
At the least, when you hear the &ldquo;same language&rdquo; justification, you should be
looking for places where the same justification could be made but you don&rsquo;t
find it convincing. If the justification isn&rsquo;t convincing when you substitute
analogous elements, then either the justification is flawed or it is missing
something that would differentiate the two situations.</p>

<p>Often, the same language justification for using Node.js is promoted by people
who are also bragging about being polyglot programmers. Not only is knowing
more than one programming language beneficial, it&rsquo;s basically required these
days. But if knowing more than one language is offered as a positive, why is
it important to use the same language on client and server? I&rsquo;m not saying
this argument is invalid, but rather that the justification should examined
for consistency.</p>

<p>Another reason given for using Node.js is that there are many Javascript
programmers. However, statistically, that means there are many mediocre or
poor quality Javascript programmers. And if concurrent applications are so
hard, do you want a lot of mediocre or poor programmers building them? Again,
many Javascript programmers <em>may</em> be a justification for using Node.js but by
itself, the justification is problematic. It&rsquo;s likely an extreme
over-simplification. As such, it has dubious value as more than just a
convenient dismissal of someone who challenges the rationale for using
Node.js.</p>

<p>It may be that using Node.js is just more fun for many people. This is a great
reason to use Node.js. However, it is not one that can be used to evaluate the
technical merit of the technology. Which is fine. Recall that I&rsquo;m asserting
programming is a <em>behavioral</em> science. We should be studying and giving
adequate weight to considerations that are not merely technical. Humans are
using Node.js.</p>

<p>Finally, despite being controversial, I&rsquo;m going to give some opinions about
Node.js based on my experience. The point is not whether you believe me or
not.  These opinions should be examined critically with the objective of
determining their validity using methods suggested above.</p>

<p>More CPU cores is the trend for the future. Typical programs have a huge
amount of state. Every library loaded is program state. Running multiple
processes demands duplicating the memory used by each process times the
number of running processes. As long as the total memory needed to saturate
the CPU cores is less than the memory available, using processes should not be
a problem. However, we have seen in Ruby, at least, that it is not typically
the case. Memory pressure is a constant problem. Solutions to this memory
pressure like copy-on-write (CoW) friendly garbage collection are hard and not
guaranteed to be that effective. If the mutable part of the heap is small
then there is also very likely little shared state that would complicate
simply using threads. If the mutable part is large, you get the same memory
pressure over time regardless of CoW-friendly GC.</p>

<p>Since it is extremely unlikely that Javascript will add threads to the
standard, Node.js will either be essentially single-threaded or programs will
use non-standard libraries to introduce threading. This forces Node.js to use
process concurrency to achieve parallelism. In this respect, I think that
Node.js rejects the multi-core reality that confronts us.</p>

<p>In fact, Node.js is already confronting the issue of process concurrency. In
Ruby, we have <a href="http://www.modrails.com/">Passenger</a> for managing multiple
worker processes.  There is now a similar system for Node.js called
<a href="http://learnboost.github.com/cluster/">Cluster</a>.</p>

<p>Another concern is that an entire ecosystem of libraries and tools must be
built up for Node.js. Javascript was confined to the browser of a long time,
and that environment is quite impoverished. In building those libraries, many
mistakes that have been make in other languages will be made again. That is
simply the nature of humans doing work. We make mistakes. Ruby and other
languages have repeated mistakes from languages that came before them. I&rsquo;m not
saying that the work that must be done won&rsquo;t be offset by its future value. I
am saying the work must be done and its value should be questioned. There is
always an opportunity cost for choosing to do an activity. It is the cost of
not doing another activity. In attempting to answer the question whether
Node.js is better for our problem, we must consider these issues.</p>

<p>Concurrency is definitely a concern for practically every currently popular
programming language. If you have heard that Node.js enables solutions not
possible in other languages, I encourage you to look more deeply into the
situation. In Ruby, I recommend checking out the
<a href="https://github.com/celluloid">Celluloid</a> project by Tony Arcieri. The
project&rsquo;s aim is to bring various concurrency mechanisms to Ruby. He is
someone with a lot of experience and accomplishments and I&rsquo;m confident his
projects will advance the state of the art in Ruby and hopefully other
languages as well. If you are a Clojure enthusiast, you may want to look at
Carl Lerche&rsquo;s <a href="https://github.com/momentumclj/momentum">momentum</a> project. Of
course, there are many languages and frameworks that handle concurrency and
more are under active development. Node.js is not new technology; it&rsquo;s merely
new for Javascript.</p>

<p>Ultimately, the answer to, &ldquo;Is Node.js better?&rdquo; is not that important. People
will use Node.js even if it&rsquo;s not the best solution to their problem. Other
people will not use it even if it is great for their particular problem. Both
results limit the benefits available to all of us. Further, we will continue
to confront the question, &ldquo;is this better than that?&rdquo; If we improve our
ability to answer that question, hopefully we will increase the benefit to us
all.</p>
</div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2011/10/3/nikita-the-ruby-secret-agent-slides">Slides for "Nikita - The Ruby Secret Agent"</a></h2>
            <div class="meta">
        <p><span class="date">03 October 2011</span></p>
      </div>

       <div class="entrybody"><p><strong>ED.</strong> I&rsquo;ve converted the slides to PDF and uploaded them to
<a href="http://speakerdeck.com/u/brixen/p/nikita-the-ruby-secret-agent">speakerdeck.com</a>.</p>

<p><a href="http://speakerdeck.com/u/brixen/p/nikita-the-ruby-secret-agent">
  <img src="/images/nikita_slides.jpg" /></a></p>

<p><strong>ED.</strong> The except from the 2011 OSCON Twitter talk is below.</p>

<iframe src="http://player.vimeo.com/video/29993216?title=0&amp;byline=0&amp;portrait=0" width="750" height="420" frameborder="0"></iframe>

</div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2009/3/18/a-vm-by-any-other-name">A VM by any other name</a></h2>
            <div class="meta">
        <p><span class="date">18 March 2009</span></p>
      </div>

       <div class="entrybody"><p>With the recent switch away from the spaghetti stack execution model, <a href="http://rubini.us">Rubinius</a> has also acquired native threads. A big part of understanding something is syncing up our mental model with reality. If you&#8217;ve ever tried to explain what an OS is to your mom, you know that can be a challenge. So let&#8217;s peel back a few layers and see where these native thread critters fit into Rubinius.</p>
<p>Rubinius is an implementation of the Ruby programming language. One of the bigger components is the virtual machine. But what is that? Unfortunately, <em>virtual machine</em> is a label for a category of software (and maybe hardware) that, well, does a bunch of different things. Virtual machines are often thought of as virtual computers or virtual CPUs. The problem with trying to equate two things is that you look at the one you know about and try to understand the one you do not by looking for analogous structures. Therein lie the seeds of misunderstanding. Since Rubinius has this <code>vm/</code> directory, we&#8217;ve got to try to nail some of this gelatin to the wall.</p>
<p>Thinking about threads running inside a physical computer, you might visualize the relationship something like the following Ruby-ish pseudo code. As the program starts up, it creates a virtual machine.</p>
<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="k">def</span> <span class="nf">main</span>
<span class="lineno">2</span>   <span class="n">vm</span> <span class="o">=</span> <span class="no">VM</span><span class="o">.</span><span class="n">new</span>
<span class="lineno">3</span>   <span class="c1"># do some setup</span>
<span class="lineno">4</span>   <span class="n">vm</span><span class="o">.</span><span class="n">run</span>
<span class="lineno">5</span> <span class="k">end</span>
</code></pre>
</div>
<p>Sometime later in the program, you add a new thread, which might be implemented something like this.</p>
<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="k">def</span> <span class="nc">Thread</span><span class="o">.</span><span class="nf">new</span>
<span class="lineno">2</span>   <span class="n">thr</span> <span class="o">=</span> <span class="no">VM</span><span class="o">.</span><span class="n">threads</span><span class="o">.</span><span class="n">create</span>
<span class="lineno">3</span>   <span class="c1"># ...</span>
<span class="lineno">4</span>   <span class="k">return</span> <span class="n">thr</span>
<span class="lineno">5</span> <span class="k">end</span>
</code></pre>
</div>
<p>You might imagine the <code>VM</code> instance having a <code>Scheduler</code> component that would supervise the threads and arrange for running them on one or more processors or cores. In this model, the VM is really like a virtual computer in which all execution is occurring. In other words, the VM is composed of multiple threads of execution.</p>
<p>The point of this mental exercise is to expose the tacit assumptions we might have about our mapping between a real computer and the virtual machine. Now let&#8217;s delve into Rubinius.</p>
<p>The <code>main</code> function is located in <code>vm/drivers/cli.cpp</code>. The first thing it does is create an instance of <code>Environment</code>, which is composed of an instance of <code>VMManager</code>, <code>SharedState</code>, and <code>VM</code>. In the <code>Environment</code> constructor, the command line is parsed for configuration options. Then the manager creates a new shared state. The shared state creates a vm. And finally the vm is initialized. During initialization, the <code>ObjectMemory</code> is created. The object memory in turn is composed of garbage collected heaps for the young and mature generations.</p>
<p>Back in <code>main</code>, a platform-specific configuration file is loaded, the &#8220;vm&#8221; is booted, the command line is loaded into <code>ARGV</code>, the kernel is loaded (i.e. the compiled versions of the files located in the <code>kernel/</code> directory), the preemption and signal threads are started, and finally the compiled version of <code>kernel/loader.rb</code> is run, which will process the command line arguments, run scripts, start <span class="caps">IRB</span>, etc. When your script, <span class="caps">IRB</span>, <code>-e</code> command, etc. finish running, <code>loader.rb</code> finishes, <code>main</code> finishes, resources are cleaned up, and finally the process exits.</p>
<p>Whew. The point of this whirlwind tour is to illustrate that <em>VM</em> is a rather fuzzy concept, even though we have a class named <code>VM</code>. Now let&#8217;s take a look at how threads fit in.</p>
<p>Rubinius has a 1:1 native thread model. In other words, each time you do <code>Thread.new</code> in your Ruby code, the instance returned maps to a single native thread. In fact, let&#8217;s look at the code for <code>Thread.new</code> in <code>kernel/common/thread.rb</code>.</p>
<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="k">class</span> <span class="nc">Thread</span>
<span class="lineno">2</span>   <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="lineno">3</span>     <span class="n">thr</span> <span class="o">=</span> <span class="n">allocate</span>
<span class="lineno">4</span>     <span class="n">thr</span><span class="o">.</span><span class="n">initialize</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
<span class="lineno">5</span>     <span class="n">thr</span><span class="o">.</span><span class="n">fork</span>
<span class="lineno">6</span> 
<span class="lineno">7</span>     <span class="k">return</span> <span class="n">thr</span>
<span class="lineno">8</span>   <span class="k">end</span>
<span class="lineno">9</span> <span class="k">end</span>
</code></pre>
</div>
<p>The calls to <code>allocate</code> and <code>fork</code> are implemented as primitives in C++ code. They are short, so we&#8217;ll take a look at them, too.</p>
<div class="highlight"><pre><code class="cpp"><span class="lineno"> 1</span> <span class="n">Thread</span><span class="o">*</span> <span class="n">Thread</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">STATE</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 2</span>   <span class="n">VM</span><span class="o">*</span> <span class="n">vm</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">new_vm</span><span class="p">();</span>
<span class="lineno"> 3</span>   <span class="n">Thread</span><span class="o">*</span> <span class="kr">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">vm</span><span class="p">);</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span>   <span class="k">return</span> <span class="kr">thread</span><span class="p">;</span>
<span class="lineno"> 6</span> <span class="p">}</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="n">Object</span><span class="o">*</span> <span class="n">Thread</span><span class="o">::</span><span class="n">fork</span><span class="p">(</span><span class="n">STATE</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 9</span>   <span class="n">state</span><span class="o">-&gt;</span><span class="n">interrupts</span><span class="p">.</span><span class="n">enable_preempt</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span>   <span class="n">native_thread_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NativeThread</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>
<span class="lineno">12</span> 
<span class="lineno">13</span>   <span class="c1">// Let it run.</span>
<span class="lineno">14</span>   <span class="n">native_thread_</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
<span class="lineno">15</span>   <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="lineno">16</span> <span class="p">}</span>
</code></pre>
</div>
<p>The call to <code>allocate</code> creates a new instance of <code>VM</code> as thread local data. The call to <code>fork</code> creates the new native thread. The call to <code>native_thread_-&gt;run()</code> will eventually call the <code>__run__</code> method in <code>kernel/common/thread.rb</code>. Something to note about this snippet of C++ code is the nice consistency between the primitives and the Ruby code that calls them.</p>
<p>We&#8217;ve encountered the <code>VM</code> class in two contexts: 1) when starting up the Rubinius process, and 2) when creating a new <code>Thread</code>. We can consider the <code>VM</code> instance to be an abstraction of the state of a single thread of execution, and in fact, <code>state</code> is the name most often given to an instance of <code>VM</code> in the Rubinius source.</p>
<p>As we&#8217;ve seen, Rubinius as a running process is composed of various abstractions, including the <code>Environment</code>, <code>SharedState</code>, <code>NativeThread</code>, and <code>VM</code> to name a few. While it is accurate to call Rubinius a virtual machine, it is apparent that concept can cover a fair bit of complexity. But breaking it into parts makes it fairly easy to understand. Let us know what things you&#8217;d like to understand better. We have the <code>doc/</code> directory in the source that we&#8217;re (slowly) building out. If you&#8217;re interested in contributing, docs would be a great way to help everyone.</p></div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2009/3/6/come-to-the-open-source-bridge-conference">Come to the Open Source Bridge conference</a></h2>
            <div class="meta">
        <p><span class="date">06 March 2009</span></p>
      </div>

       <div class="entrybody"><p>If you live in or would like to visit beautiful Portland, OR, consider <a href="http://opensourcebridge.org/attend/">signing up</a> for the <a href="http://opensourcebridge.org/">Open Source Bridge</a> conference. I will (probably) be giving a talk on <a href="http://opensourcebridge.org/proposals/13">RubySpec</a> and <a href="http://opensourcebridge.org/proposals/12">Rubinius 1.0</a>. There&#8217;s lots of interesting folks giving great <a href="http://opensourcebridge.org/events/2009/proposals/">talks</a>. This is an opportunity to hear how people are developing the open-source community.</p>
<p>Hope to see you there!</p></div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2009/3/3/when-describe-ing-it-ain-t-enough">When describe'ing it ain't enough</a></h2>
            <div class="meta">
        <p><span class="date">03 March 2009</span></p>
      </div>

       <div class="entrybody"><p>One of the things I like about the <a href="http://rspec.info">RSpec</a> syntax is that it packs a lot of information into a few concise, consistent constructs. It&#8217;s relatively easy to read through a spec file and pick out what I am looking for. The use of blocks both enable flexible execution strategies and provide simple containment boundaries.</p>
<p>Perhaps the most valuable aspect, though, is the ability to extend the RSpec syntax constructs easily and consistently. No need to grow a third arm here. In <a href="http://rubini.us">Rubinius</a>, we recently encountered a situation needing some extra sauce when fixing our compiler specs.</p>
<p>A compiler can be thought of as something that chews up data in one form and spits it out in another, equivalent, form. Typically, these transformations from one form to another happen in a particular order. And there may be several of them from the very beginning to the very end of the compilation process.</p>
<p>To write specs for such a process, it would be nice to focus just on the forms of the data (that&#8217;s what we care about) with as little noise as possible about how they got there. Here&#8217;s what we have in Rubinius:</p>
<div class="highlight"><pre><code class="ruby"><span class="lineno"> 1</span> <span class="n">describe</span> <span class="s2">&quot;An And node&quot;</span> <span class="k">do</span>
<span class="lineno"> 2</span>   <span class="n">relates</span> <span class="s2">&quot;(a and b)&quot;</span> <span class="k">do</span>
<span class="lineno"> 3</span>     <span class="n">parse</span> <span class="k">do</span>
<span class="lineno"> 4</span>       <span class="o">[</span><span class="ss">:and</span><span class="p">,</span> <span class="o">[</span><span class="ss">:call</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:a</span><span class="p">,</span> <span class="o">[</span><span class="ss">:arglist</span><span class="o">]]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:call</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:b</span><span class="p">,</span> <span class="o">[</span><span class="ss">:arglist</span><span class="o">]]]</span>
<span class="lineno"> 5</span>     <span class="k">end</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span>     <span class="n">compile</span> <span class="k">do</span> <span class="o">|</span><span class="n">g</span><span class="o">|</span>
<span class="lineno"> 8</span>       <span class="n">g</span><span class="o">.</span><span class="n">push</span> <span class="ss">:self</span>
<span class="lineno"> 9</span>       <span class="n">g</span><span class="o">.</span><span class="n">send</span> <span class="ss">:a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kp">true</span>
<span class="lineno">10</span>       <span class="n">g</span><span class="o">.</span><span class="n">dup</span>
<span class="lineno">11</span> 
<span class="lineno">12</span>       <span class="n">lhs_true</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_label</span>
<span class="lineno">13</span>       <span class="n">g</span><span class="o">.</span><span class="n">gif</span> <span class="n">lhs_true</span>
<span class="lineno">14</span> 
<span class="lineno">15</span>       <span class="n">g</span><span class="o">.</span><span class="n">pop</span>
<span class="lineno">16</span>       <span class="n">g</span><span class="o">.</span><span class="n">push</span> <span class="ss">:self</span>
<span class="lineno">17</span>       <span class="n">g</span><span class="o">.</span><span class="n">send</span> <span class="ss">:b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kp">true</span>
<span class="lineno">18</span> 
<span class="lineno">19</span>       <span class="n">lhs_true</span><span class="o">.</span><span class="n">set!</span>
<span class="lineno">20</span>     <span class="k">end</span>
<span class="lineno">21</span>   <span class="k">end</span>
<span class="lineno">22</span> <span class="k">end</span>
</code></pre>
</div>
<p>The <code>relates</code> block introduces the Ruby source code and contains the blocks that show various intermediate forms. A single word like <code>parse</code> and <code>compile</code> encapsulates the process of generating that particular form, as well as concisely documenting the specs.</p>
<p>The format is sufficiently flexible to allow for other forms. For instance, <code>ast</code> for generating an <span class="caps">AST</span> directly from the parse tree rather than using the sexp as an intermediate form. Or <code>llvm</code> to emit <a href="http://llvm.org"><span class="caps">LLVM</span></a> IR directly from our compiler.</p>
<p>Another interesting aspect of this, it was possible with only a few custom extensions to <a href="http://github.com/rubyspec/mspec/commits/master">MSpec</a>. Recently, I had added custom options to the MSpec runner scripts to enable such things as our <code>--gc-stats</code>. I didn&#8217;t know how easy it would be to add something more extensive. Turns out it was pretty easy. You can check out the source in our <a href="http://github.com/evanphx/rubinius/tree/master/spec/custom">spec/custom</a> directory.</p></div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2009/3/3/what-is-rubyspec">What is RubySpec?</a></h2>
            <div class="meta">
        <p><span class="date">03 March 2009</span></p>
      </div>

       <div class="entrybody"><p>According to the folks over at <a href="http::rubyspec.org">http://rubyspec.org</a>, &#8220;RubySpec is a project to write a complete, executable specification for the Ruby programming language.&#8221; As with any sufficiently concise summary, there&#8217;s some opportunity for misunderstanding here, so let&#8217;s explore a few aspects of this definition.</p>
<p>Since this post is a bit long, here&#8217;s a summary:</p>
<ol>
	<li>There is one <em>standard</em> definition of Ruby.</li>
	<li>RubySpec benefits the whole Ruby ecosystem.</li>
	<li>RubySpec does not guarantee that program A will run on implementation B.</li>
	<li>RubySpec includes only specs for the correct behavior when bugs are discovered in <span class="caps">MRI</span>.</li>
	<li>Help your favorite Ruby implementation by contributing to RubySpec.</li>
</ol>
<p>First, what does it mean to be &#8220;the Ruby programming language&#8221;? The answer to this question used to be a little simpler before Ruby 1.9. Originally, there was the single Ruby implementation that Matz and friends built, referred to as <span class="caps">MRI</span> (Matz&#8217;s Ruby Interpreter). Now there is also RubyVM or <span class="caps">KRI</span> (Koichi&#8217;s Ruby Implementation) or simply Ruby 1.9. Either way, <span class="caps">MRI</span> 1.8.x and [KM]RI 1.9.x are the <em>standard</em> or <em>reference</em> implementations for Ruby. Everyone else is making an alternative implementation that either complies with the standard or deviates from it.</p>
<p>This is the way RubySpec is written. I realize that it&#8217;s possible to consider &#8220;the Ruby programming language&#8221; to be an abstract thing and <em>all</em> the Ruby projects as merely more or less equal attempts to implement the language. I won&#8217;t try to convince you that either way of viewing this is more or less correct. I just want to be clear about the way RubySpec views it.</p>
<p>At the time I began writing what eventually became RubySpec, the only Ruby implementation in wide-spread use was <span class="caps">MRI</span>. My biggest concern when getting involved with <a href="http://rubini.us">Rubinius</a> was that the project would be consistent with Ruby the way Matz defines it and not cause fragmentation of the language. My reason was quite selfish. I loved programming in Ruby and I wanted to see the language thrive.</p>
<p>So, RubySpec&#8217;s over-arching value proposition is a single, comprehensive definition of the Ruby programming language. To see if the value proposition is actually universal, let&#8217;s examine the three categories of people involved with Ruby: consumers, programmers, and implementers.</p>
<p>I define <em>consumers</em> as anyone who depends on a product or service written in Ruby. Consumers may use these products and services directly, or they may own or work for companies that provide them, or they may use products and services that are themselves supported by software written in Ruby. Consumers are the biggest part of the Ruby ecosystem.</p>
<p>Interacting closely with the consumers are <em>programmers</em>, the men and women who write software or frameworks in Ruby. In fact, the same folks may be both consumers and programmers.</p>
<p>The <em>implementers</em> are the people writing Ruby implementations for the programmers and consumers. They want to experiment with ways to better support programmers without worrying that they are breaking their programs in unknown ways. Again, the implementers may be programmers or consumers themselves.</p>
<p>If you&#8217;ve ever used a proprietary implementation of a programming language or know what vendor lock-in means, then I am preaching to the choir. If not, then consider that system requirements change, hardware changes, services change, customers change, development teams change, everything changes.</p>
<p>Consumers want assurance that the products and services on which they depend will remain available and will grow with their needs. Programmers want assurance that they will be able to meet their customers&#8217; needs. Implementers want to provide programmers the ability to do so. A single, consistent Ruby language really is a win-win-win situation.</p>
<p>With everything seeming so sunny, one may be tempted to think: &#8220;If implementation A and B perform the same on RubySpec, then a program running on A now should run just fine on B.&#8221; Unfortunately, it is not quite that simple. Just as a program may not run on both OS X and Linux simply because <span class="caps">MRI</span> runs on both. Once in a while, RubySpec finds bugs in <span class="caps">MRI</span>, though not that often considering the tens of thousands of expectations. Since a lot of the code in <span class="caps">MRI</span> has been around for years, this illustrates that even running thousands of programs (RubySpec is just another program) is no guarantee that there are not bugs lurking around the corner.</p>
<p>What can tell you whether a program will (likely) run on both A and B is the program&#8217;s own test suite. In this regard, the program&#8217;s test suite and RubySpec are complementary. If the tests discover something that RubySpec did not, it is an opportunity to enhance RubySpec. If running on another implementation expose issues not uncovered by the program&#8217;s tests, it is an opportunity to enhance the tests.</p>
<p>Ruby versioning is complex affair and another area where possible misunderstandings exist about RubySpec. It seems pretty simple that Ruby 1.8 and Ruby 1.9 are different. But then there is 1.8.7, which is like 1.8.6 and 1.9. And there may be 1.8.8, which will likely be different than 1.8.6 and 1.8.7 and 1.9. It is dizzying. RubySpec handles the different versions by using the <code>ruby_version_is</code> guard. (Read the <a href="http://rubyspec.org/wiki/rubyspec/Guards">guard documentation</a> for full details.)</p>
<p>Generally, the version guards work fine. Each implementation provides the <code>RUBY_VERSION</code> constant and based on its value, the guards permit the correct specs to run. Some have assumed this means RubySpec will tell you that alternate implementation A is just like <span class="caps">MRI</span> version X.Y.Z &#8220;bugs and all&#8221; because A says it is version X.Y.Z.</p>
<p>The principles RubySpec strives for are correctness, clarity, and consistency. There is no way to provide <em>clear</em> and <em>consistent</em> results if RubySpec included specs for the <em>wrong</em> behavior as well as specs for the correct behavior. Either clarity or consistency suffer, badly. Matz is the one who ultimately determines whether a behavior is a bug or not. RubySpec simply includes specs for only correct behaviors.</p>
<p>These are some of the factors that complicate this issue:</p>
<ol>
	<li>There is no definition of what <em>is</em> a bug. It may be a segfault, an incorrect value computed, a frozen state not set or respected, the wrong exception class raised. The list is endless and impossible to consistently categorize.</li>
	<li>All implementations, including <span class="caps">MRI</span>, have their own release processes and schedules.</li>
	<li>RubySpec is a social as well as technical project. An aspect of the value-added proposition for any given implementation is the quality that they provide. There is no way the alternative implementations will consistently agree to defer fixing bugs until <span class="caps">MRI</span> releases a fix. Rather than supporting cherry-picking which bugs to fix, RubySpec only includes correct specs.</li>
	<li>Bugs discovered by RubySpec in <span class="caps">MRI</span> are quite rare.</li>
</ol>
<p>Finally, contributing to RubySpec is one of the lowest barriers-to-entry means of supporting your favorite Ruby implementation and the Ruby ecosystem as a whole.</p>
<p>Consider what the view looks like from the outside: Ruby has a vibrant community of implementations meeting consumers&#8217; and programmers&#8217; needs on virtually every significant platform, including on Java, .<span class="caps">NET</span>, Mac (Obj-C), and semi-platform-agnostic implementations like <span class="caps">MRI</span> and Rubinius. Internally, it means that Ruby programmers can focus more on writing their programs using the best tools for the job, confident that if requirements change they can move to a different platform with ease and confidence.</p>
<p>Check out the <a href="http://rubyspec.org/wiki/rubyspec">RubySpec docs</a> if you are interested in helping out.</p></div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2009/3/3/boxers-or-briefs-neither">Boxers or Briefs? -- Neither?!</a></h2>
            <div class="meta">
        <p><span class="date">03 March 2009</span></p>
      </div>

       <div class="entrybody"><p>The emperor is wearing clothes and everything looks hunky-dory and sane on the outside. Usually, that&#8217;s a good thing. For instance, when running <a href="http://rubyspec.org">RubySpec</a> on a released version of <span class="caps">MRI</span>, it&#8217;s good to know that things are behaving as expected and <em>all known issues</em> are accounted for. In other words, you won&#8217;t see any failures unless a spec is broken or a new spec has uncovered a bug.</p>
<pre>
$ mspec library/stringio/reopen_spec.rb 
ruby 1.8.6 (2008-03-03 patchlevel 114) [universal-darwin9.0]
........................

Finished in 0.021797 seconds

1 file, 24 examples, 59 expectations, 0 failures, 0 errors
</pre>
<p>While the above can be reassuring, it may not tell the whole story. RubySpec uses <a href="http://rubyspec.org/wiki/rubyspec/Guards">guards</a> to control which specs are run. This enables the specs to accommodate differences in behavior due to varying platforms, versions, implementations, and bugs.</p>
<p>I&#8217;ve added a couple features to <a href="http://github.com/rubyspec/mspec/commits/master">MSpec</a> to enable discrete and not-so-discrete peeks under the robes, as it were. The first of these is akin to just yanking down the trousers. By passing the <code>--no-ruby_bug</code> option, all <code>ruby_bug</code> guards are disabled and the guarded specs are run.</p>
<pre>
$ mspec --no-ruby_bug library/stringio/reopen_spec.rb 
ruby 1.8.6 (2008-03-03 patchlevel 114) [universal-darwin9.0]
............FF.....FF.....FF......

1)
StringIO#reopen when passed [Object, Object] resets self's position to 0 FAILED
Expected 5
 to have same value and type as 0

./library/stringio/reopen_spec.rb:117
./library/stringio/reopen_spec.rb:110:in `all?'
./library/stringio/reopen_spec.rb:61

---- snip ----

Finished in 0.022210 seconds

1 file, 34 examples, 76 expectations, 6 failures, 0 errors
</pre>
<p>If you cringe a little when blasted by a bunch of failures, don&#8217;t worry, So do I. For a more subtle examination, there is also the ability to run the specs and note which specs <em>would have run</em> but did not due to guards.</p>
<pre>
$ mspec --report library/stringio/reopen_spec.rb 
ruby 1.8.6 (2008-03-03 patchlevel 114) [universal-darwin9.0]
........................

Finished in 0.009809 seconds

1 file, 24 examples, 59 expectations, 0 failures, 0 errors, 10 guards


4 specs omitted by guard: ruby_bug #, 1.8.6.114:

StringIO#reopen reopens a stream when given a String argument
StringIO#reopen reopens a stream in append mode when flagged as such
StringIO#reopen reopens and truncate when reopened in write mode
StringIO#reopen truncates the given string, not a copy

6 specs omitted by guard: ruby_bug #, 1.8.7:

StringIO#reopen when passed [Object, Object] resets self's position to 0
StringIO#reopen when passed [Object, Object] resets self's line number to 0
StringIO#reopen when passed [String] resets self's position to 0
StringIO#reopen when passed [String] resets self's line number to 0
StringIO#reopen when passed no arguments resets self's position to 0
StringIO#reopen when passed no arguments resets self's line number to 0
</pre>
<p>The guards are reported only if they have altered how the specs were run. Since the <code>ruby_bug</code> guard can only prevent specs from running on the <em>standard implementation</em>, <span class="caps">MRI</span>, those guards are not reported when running under JRuby, for instance.</p>
<pre>
$ mspec -t jruby --report library/stringio/reopen_spec.rb 
jruby 1.2.0RC1 (ruby 1.8.6 patchlevel 287) (2009-02-26 rev 9326) [i386-java]
..................................

Finished in 0.257000 seconds

1 file, 34 examples, 76 expectations, 0 failures, 0 errors, 0 guards
</pre>
<p>So, if you are wondering what is going on with some specs for a particular library, you can get a quick peek using the <code>--report</code> option before digging into the spec files. There is also a <code>--report-on GUARD</code> option that allows you to narrow the focus of your peeking.</p></div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2009/2/26/warning-includes-known-bugs">Warning: Includes Known Bugs</a></h2>
            <div class="meta">
        <p><span class="date">26 February 2009</span></p>
      </div>

       <div class="entrybody"><p><strong><span class="caps">UPDATE</span>:</strong> In further discussions with Jim Deville of IronRuby it appears that there may be a legal issue preventing IronRuby devs from patching Ruby code themselves. However it may be possible for IronRuby to use a commonly maintained and patched version of the standard library.</p>
<p>Reviewing the logs and considering this was Shri&#8217;s first major discussion in the <span class="caps">IRC</span> channel, I unfortunately grouped him in with Charles&#8217; intolerable behavior and personal attacks which have occurred on a number of occasions in #rubyspec and #rubinius. My apologies to Shri. The struck out text below remains merely for historical accuracy.</p>
<p><strong><span class="caps">UPDATE</span>:</strong> Charles response to this post wasn&#8217;t exactly positive, but I think it&#8217;s fair to have this discussion in public: <a href="http://pastie.org/400493">http://pastie.org/400493</a> Also, please note that I&#8217;ve struck out Shri&#8217;s name below as I may have misunderstood him in the earlier discussion.</p>
<hr />
<p>You, the trusting consumer, would probably like to receive such cautionary advertisement were you to use a product that did, in fact, ship to you code that includes known bugs. And not just known bugs, but known bugs that have fixes for them.</p>
<p>You would like to know this, right? I mean, I&#8217;m not just some hard-headed asshole that thinks there&#8217;s something a bit whack here, am I? Please, do tell me.</p>
<p>Well, as luck would have it, you can also tell this to <a href="http://http://blog.headius.com/">Charles Oliver Nutter</a> of <a href="http://jruby.codehaus.org/">JRuby</a> <del>and <a href="http://blogs.msdn.com/shrib/">Shri Borde</a> of <a href="http://www.ironruby.net/">IronRuby</a></del>.</p>
<p>Here&#8217;s the drama: There&#8217;s this project <a href="http://rubyspec.org">RubySpec</a>. You may have heard of it. It attempts to describe the behavior of the Ruby programming language. All the alternative Ruby implementations use the RubySpec project to attempt to show that they are &#8220;Ruby&#8221;.</p>
<p>All the alternative implementations also choose to ship some version or other of the Ruby standard library. At least the parts written in Ruby. Makes sense, since they all implement the Ruby programming language.</p>
<p>As is the case with all software, from time to time bugs are discovered in Ruby. Usually, these are fixed soon after they are discovered and the fix is committed to the trunk version of <span class="caps">MRI</span> (Matz&#8217;s Ruby Implementation). Eventually, trunk becomes another stable release with a particular patchlevel.</p>
<p>The RubySpecs deal with this situation with a <code>ruby_bug</code> guard. You can read the details of <a href="http://rubyspec.org/wiki/rubyspec/Guards">RubySpec guards</a>. This particular guard has two functions:</p>
<ol>
	<li>It prevents the guarded spec from executing on any version of <span class="caps">MRI</span> less than or equal to the version specified in the guard. This is because <span class="caps">MRI</span> cannot re-release a particular patchlevel <em>after</em> it has been released. And the bugs are discovered <em>after</em> a release.</li>
	<li>It documents the spec, which shows what the correct behavior should be.</li>
</ol>
<p>A key feature of the <code>ruby_bug</code> guard is that it <em>does not</em> prevent the spec from running on any alternative implementation. That is because every alternative implementation is expected to have the <em>correct</em> behavior. Additionally, these guards are only added after Matz or ruby-core has stated that the behavior at issue is a bug and the behavior of the spec is the correct behavior.</p>
<p>Now here is the rub, Charles does not want to manage patching the Ruby standard library that he ships with JRuby <em>with the patches that already exist for known bugs</em>. He wants to ship whatever version <span class="caps">MRI</span> has most recently released. Further, when you run the RubySpecs with JRuby, he wants to <em><strong><span class="caps">MASK</span></strong></em> those bugs because he doesn&#8217;t think it&#8217;s fair that JRuby fails a spec which shows a known bug in the Ruby standard library for which patches are available.</p>
<p>That&#8217;s Charles choice of strategies for managing JRuby packaging. I&#8217;m strongly of the opinion that you, the user, would like to know that. Charles apparently disagrees.</p>
<p>In fact, he disagrees so vehemently that he takes to calling me names in the #rubyspec <span class="caps">IRC</span> channel because I refuse to change the fact that the <code>ruby_bug</code> guard will not silently mask spec failures on JRuby or any other alternative implementation. Aside from being immature, I think there is a real problem with this. Don&#8217;t you?</p>
<p>Charlie will argue that it is simply impossible to ship the trunk version of Ruby standard library because it is an unknown quantity? However, the best defense against bugs in the Ruby standard library is better specs. And we&#8217;re talking about specs here that <em>show the bugs</em> and for which patches exist. Furthermore, there are actually relatively few bugs noted in the specs and most of those are in older versions of Ruby, not the current stable release.</p>
<p>So, here&#8217;s my question to you: Would you like to know that JRuby <del>and possibly IronRuby</del> ship you code that contains know bugs for which patches exist? Would you also like to know that Charles wants you to run RubySpec on JRuby and not know there is a bug?</p></div>
    </div>
    
    <div class="entry home">
      <h2 class="entrytitle"><a href="/2009/2/20/caveat-lector">Caveat Lector</a></h2>
            <div class="meta">
        <p><span class="date">20 February 2009</span></p>
      </div>

       <div class="entrybody"><p>I really did double-check this time and I won&#8217;t be making any wild claims here. Sorry to disappoint.</p>
<p>We&#8217;re going to be running <a href="http://antoniocangiano.com/">Antonio&#8217;s</a> <a href="http://github.com/acangiano/ruby-benchmark-suite/tree/master">Ruby Benchmark Suite</a> daily to track our progress on performance in <a href="http://rubini.us">Rubinius</a>. The current <span class="caps">RBS</span> is a bit of a beast so I imported the files into the Rubinius <a href="http://github.com/evanphx/rubinius/commits/master">repository</a> and did some refactoring. You can <a href="http://groups.google.com/group/ruby-benchmark-suite/browse_frm/thread/34b7b7472fa5b80">read the details</a> and up-vote that if you&#8217;d like to see this merged back.</p>
<p>Now, for some baseline <span class="caps">RBS</span> results. If you want to follow along at home, here&#8217;s what I did. I generated these by running the <code>rake bench</code> task using the <code>VM</code> option (see the benchmark/utils/<span class="caps">README</span> in the Rubinius repository) for Rubinius on the <code>stackfull</code> and <code>master</code> branch and for <span class="caps">MRI</span> using the version installed on Debian lenny, 1.8.7p22. The system is a dual Intel&#174; Xeon&#8482; <span class="caps">CPU</span> 2.40GHz. Then I ran the <code>rake bench:to_csv</code> task, imported the <span class="caps">CSV</span> file into Google Docs, added the comparison columns and colors, and exported to <span class="caps">PDF</span>.</p>
<p><a href="http://blog.brightredglow.com/assets/2009/2/20/mini-rbx-shootout.jpg">Here&#8217;s what I got.</a> The green is faster, the red is slower. The reported time is the minimum time recorded in five &#8220;iterations&#8221; of each benchmark per input. The maximum time allowed to run five iterations is 300 seconds, or an average of 60 seconds per iteration.</p>
<p>A few notes about these numbers:</p>
<ul>
	<li>We&#8217;re still fixing the breakage on the stackfull branch, so it is not surprising, for instance, that all the thread benchmarks errored out. The new native thread support is not 100% done.</li>
	<li>There are a couple speed regressions on the stackfull branch, most minor. We&#8217;ll fix those.</li>
	<li>Most of the benches do run on the stackfull branch.</li>
	<li>On most of the benches that run slower in stackfull than <span class="caps">MRI</span>, we&#8217;re 2x or less slower than <span class="caps">MRI</span>.</li>
	<li>We are <em>a lot</em> faster than <span class="caps">MRI</span> on quite a few benchmarks.</li>
	<li>Rubinius on either branch does quite well relative to <span class="caps">MRI</span> on benches that <span class="caps">MRI</span> times-out on for certain inputs.</li>
</ul>
<p>Perhaps the biggest point about the stackfull branch is that we haven&#8217;t done much optimization at all. Evan&#8217;s been coding in the basic new interpreter architecture, fixing the GC interaction, adding the native threading. We&#8217;re fixing breakage now so we can get this merged into the master branch. The <span class="caps">JIT</span> is not hooked up. The new GC work is not done. There is no inlining. In other words, there is lots of head room. And that is the key point. You can&#8217;t just &#8220;make it faster&#8221;. Architecture is crucial. Since RailsConf 2008, we&#8217;ve been working hard to lay the architectural foundations. With those (and the switch away from stackless), we can start focusing on the real dynamic language optimizations.</p>
<p>While the benchmarks tell part of the story, there&#8217;s another part that is even more interesting <span class="caps">IMO</span>. And this is the part that <a href="http://blog.brightredglow.com/2009/2/12/all-shiny-and-new">got me so excited</a> I, um, well I <a href="http://blog.brightredglow.com/2009/2/12/this-is-not-cold-fusion">just got excited</a>&#8230;</p>
<p>The two biggest pieces of Ruby software that we most often run are the Rubinius compiler and the <a href="http://rubyspec.org">RubySpecs</a>. The RubySpecs are much more &#8220;real-world&#8221; than these benchmarks. Here are the results of two complete CI runs on master and stackfull. Note that we are not quite running all the basic CI specs on stackfull, but we&#8217;ll figure in that difference in our calculations below.</p>
<p>First, on master:</p>
<pre style="overflow:auto">
  $ bin/mspec ci --gc-stats
  rubinius 0.10.0 (ruby 1.8.6) (f4c5576c4 12/31/2009) [i686-apple-darwin9.6.0]

  Finished in 131.248169 seconds

  1430 files, 6927 examples, 23006 expectations, 0 failures, 0 errors

  Time spent in GC: 51.6s (39.3%)
</pre>
<p>And then on stackfull:</p>
<pre style="overflow:auto">
  $ bin/mspec ci --gc-stats
  rubinius 0.11.0-dev (ruby 1.8.6) (e7b6a2d56 12/31/2009) [i686-apple-darwin9.6.0]

  Finished in 66.357996 seconds

  1349 files, 6298 examples, 21344 expectations, 0 failures, 0 errors

  Time spent in GC: 12.7s (19.1%)
</pre>
<p>Let&#8217;s calculate how we do in expectations per second:</p>
<pre>
  $ irb
  &gt;&gt; master = 23006 / 131.248169
  =&gt; 175.286254850534
  &gt;&gt; stackfull = 21344 / 66.357996
  =&gt; 321.649255351232
  &gt;&gt; stackfull / master
  =&gt; 1.83499416782851
</pre>
<p>So, compiling and running the specs is about 1.8 times faster on stackfull. This is upside down from the normal results. Normally, we do better on the micro benchmarks and see that invert on &#8220;macro&#8221; benchmarks. On the <span class="caps">RBS</span> benches, stackfull is not 1.8 times faster than master. If I average the &#8220;x Master&#8221; column, I get 1.39.</p>
<p>There was something else in those spec run numbers I wanted to talk about&#8230; oh yeah, GC stats. We have a very simple GC timer stat right now. I&#8217;m going to be adding a few more stats. But what we see here is that the overall percentage of time spent in GC drops by half in stackfull. Even so, 19% is too much time to spend in GC. We expect to drop that by half again. Basically, leaning more on structures <code>alloca'd</code> on the C stack reduces a lot of pressure on the GC.</p>
<p>Some would toss out that it&#8217;s not hard to be faster than <span class="caps">MRI</span>. Perhaps. But it is an accomplishment to write a reasonably good VM, garbage collector, compiler, and Ruby standard library without importing anyone else&#8217;s code. And, lest we forget, that is two VM&#8217;s in about 27 months of a public project.</p>
<p>Some would also question the sanity of writing a VM and garbage collector when crazy smart people do things like that. Well, crazy smart people write papers that reasonably smart people can read and understand. From the benchmark result above, that is working pretty well.</p>
<p>Here&#8217;s the point: Don&#8217;t ever let anyone tell you that something is a bad idea. Make your own decisions. We probably wouldn&#8217;t have Ruby itself if Matz fretted over whether Larry Wall or Adele Goldberg were smarter than he. My most recent favorites in this space: <a href="http://factorcode.org/">Factor</a>, <a href="http://clojure.org">Clojure</a>, and yes, <a href="http://code.macournoyer.com/tinyrb/">tinyrb</a>.</p>
<p>We&#8217;re working frantically to get the stackfull branch breakages fixed and the branch merged back into master. Feel free to poke around and ask questions.</p></div>
    </div>
    
    </div>
        <div id="sidebar">
      <div id="subscribe">
        <a type="application/rss+xml" rel="alternate" title="Subscribe to my feed" href="/feed/atom.xml">
          <img alt="subscribe" src="/images/feed.png" />
        </a>
      </div>

      <div>
        <p>I work at <a href="http://engineyard.com">Engine Yard</a> on <a href="http://rubini.us">Rubinius</a>. <a href="http://engineyard.com">Engine Yard offers Rails Hosting.</a></p>
      </div>

      <h2 id="latest_posts">Latest posts</h2>
      <ul>
      
        <li><a href="/2012/12/11/a-ruby-design-process">A Ruby Design Process</a></li>
      
        <li><a href="/2012/4/9/is_node_js_better">Is Node.js Better?</a></li>
      
        <li><a href="/2011/10/3/nikita-the-ruby-secret-agent-slides">Slides for "Nikita - The Ruby Secret Agent"</a></li>
      
        <li><a href="/2009/3/18/a-vm-by-any-other-name">A VM by any other name</a></li>
      
        <li><a href="/2009/3/6/come-to-the-open-source-bridge-conference">Come to the Open Source Bridge conference</a></li>
      
        <li><a href="/2009/3/3/when-describe-ing-it-ain-t-enough">When describe'ing it ain't enough</a></li>
      
        <li><a href="/2009/3/3/what-is-rubyspec">What is RubySpec?</a></li>
      
        <li><a href="/2009/3/3/boxers-or-briefs-neither">Boxers or Briefs? -- Neither?!</a></li>
      
        <li><a href="/2009/2/26/warning-includes-known-bugs">Warning: Includes Known Bugs</a></li>
      
        <li><a href="/2009/2/20/caveat-lector">Caveat Lector</a></li>
      
        <li><a href="/2009/2/12/this-is-not-cold-fusion">This is NOT cold fusion</a></li>
      
        <li><a href="/2009/2/12/all-shiny-and-new">All shiny and new</a></li>
      
        <li><a href="/2008/11/23/call-of-the-lemmings">Call of the lemming</a></li>
      
        <li><a href="/2008/11/18/rubinius-is-a-community-project">Rubinius is a community project</a></li>
      
        <li><a href="/2008/9/3/hash-is-all-ponies">Hash is all ponies</a></li>
      
      </ul>
      <p><a href="/posts_index.html">Show All Posts</a></p>
    </div>

  </div>

    <div id="footer">def euler(x); cos(x) + i*sin(x); end is using theme based
    on <a href="http://ananasblau.com/themes/ananasblau">ananasblau</a> and
    generated with <a href="http://jekyllrb.com/">Jekyll</a></div>


</body>
</html>
